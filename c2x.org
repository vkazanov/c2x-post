* Включенные в черновик стандарта изменения

** Атрибуты

   Известные мне компиляторы C каждый реализуют свое надмножество языкового стандарта.
   Помимо нестандартных языковых конструкций программисты могут указать в объявлениях,
   например, переменных /атрибуты/, уточняющие поведение компиляторов.

   Атрибуты в опубликованных версиях стандарта не упоминаются, но так или иначе
   [[https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html][реализованы]] [[https://clang.llvm.org/docs/AttributeReference.html][основными]] компиляторами.

   В новую версию стандарта принимается [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf][новый синтаксис]] атрибутов. Пример из предложения:

   #+begin_src c
   [[attr1]] struct [[attr2]] S { } [[attr3]] s1 [[attr4]], s2 [[attr5]];
   #+end_src

   Здесь =attr1= относится к =s1= и =s2=, =attr2= относится к определению =struct S=, =attr3= - к типу
   =struct s1=, =attr4= - к идентификатору =s1=, =attr5= - к идентификатору =s2=.

   Заодно с синтаксисом были согласованы и некоторые атрибуты:

   1. Атрибут =deprecated= позволяет пометить объявление как устаревшее, при использовании
      таких объявлений компиляторам предлагается предупреждать программиста.

   2. Атрибутом =fallthrough= можно явно пометить места в ветвлениях =switch=, где поток
      исполнениях /должен/ обработать и следующую ветвь тоже.

   3. Явно указать необходимость обработки возвращаемого функцией значения можно с помощью
      атрибута =nodiscard=.

   4. Если переменная или функция осознанно не используется, то ее можно пометить
      атрибутом =maybe_unused= (а не почти уже идиоматичным =(void)=).

** Функции strdup и strndup

   Реализованные в POSIX, всех приличных стандартных библиотеках и компиляторах к нам,
   наконец, [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2353.htm][приходят]] функции =strdup= и =strndup=:

   #+begin_src c
     #include <string.h>

     char *strdup (const char *s);
     char *strndup (const char *s, size_t size);
   #+end_src

** Традиционный способ (K&R) указания параметров функций

   Устаревший еще в 1989 году способ объявления параметров функции, он же "объявление в
   стиле K&R", он же "когда типы после скобочек указываются", он же "я не понимаю старый
   код на C", будет, наконец, [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2432.pdf][сожжен на костре]].

   Другими словами, больше нельзя будет сделать так:

   #+begin_src c
     long maxl (a, b)
         long a, b;
     {
         return a > b ? a: b;
     }
   #+end_src

   И еще можно будет и так, и так:

   #+begin_src c
     /* вы же никогда не забывали void? */
     int no_args(void);
     /* ничего страшного, теперь это будет работать */
     int no_args();
   #+end_src

** Представление знаковых целых чисел

   Бесконечная история, наконец, пришла к завершению. Комитет [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2412.pdf][смирился]] с тем, что
   единорогов и сказочных архитектур не бывает, а все пользователи C на самом деле
   используют [[https://ru.wikipedia.org/wiki/Дополнительный_код][дополнительных код]] (англ. /two's complement/).

   В текущем виде это несколько упростит в деталях стандарт, но в перспективе может (!)
   убрать самое любимое программистами неопределенное поведение языка.

* Не утвержденные, но получившие одобрение изменения
** Безымянные параметры в определении функций

   За неделю я стабильно пишу одну-две пробные программки на C. И, признаться. мне уже
   давно надоело указывать имена неиспользованных аргументов =main=.

   [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2510.pdf][Одно]] из положительно воспринятых Комитетом предложений позволит не писать лишний раз
   имена параметров определинй функций:

   #+begin_src c
     int main(int, char *[])
     {
         /* И никакой перхоти! */
         return 0;
     }
   #+end_src

** Легализация ключевых слов

   После долгого переходного периода Комитет, наконец, [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2457.pdf][перестает]] придуриваться и [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2458.pdf][принимает]]
   в язык ключевые слова: =true=, =false=, =alignas=, =alignof=, =bool=, =static_assert= и другие. Лишние
   заголовки, кажется, можно будет почистить.
** Включение двоичных файлов в исходный файл

   Невероятно полезная всем игроделам [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2499.pdf][возможность]] - прямое включение двоичных данных из
   файлов прямо в исполняемый файл:

   #+begin_src c
     const int music[] = {
        #embed int "music.wav"
     };
   #+end_src

   Надеюсь, члены Комитета понимают, что Хабр знает, где они собираются в следующий раз и
   примут это предложение без вопросов.
** Прощай, NULL! Или nullptr на марше

   Кажется, на смену nullptr [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2394.pdf][приходит]] nullptr.

** TODO  Реформа обработки ошибок

   Обработка ошибка - давняя боль языка. Сочетание неудачных решений в ранних версиях
   стандарта с одной стороны, и консервативность комитета - с другой, не позволяли найти
   устраивающее всех решение.

   И вот, наконец, появился герой, готовый хоть что-то [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2429.pdf][предложить]].
