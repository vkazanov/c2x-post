* Аннотация

  #+begin_quote
Гул затих. Я вышел на подмостки.
Прислонясь к дверному косяку,
Я ловлю в далеком отголоске,
Что случится на моем веку.
-- "Гамлет", Борис Пастернак

  #+end_quote

  Признаться, пишу на чистом C я не так уж и часто, и за творчеством комитета WG14 уже
  давно не слежу. Но тут случилось два неожиданных события: С [[https://www.tiobe.com/tiobe-index/][вернул]] себе звание главного
  языка программирование в мире по версии TIOBE; и случился предварительный анонс первой
  за долгие годы действительно [[https://nostarch.com/Effective_C][интересной книги]] по языку.

  События эти заставили меня провести несколько вечеров в чтении логов Комитета и
  переписки членов комитета и автора книги с читателями разных онлайн-сообществ. В
  результате получился составил список ожидаемых изменений в Стандарте, которые коснутся,
  как мне кажется, и рядовых программистов тоже.

  Список этот и представляю вам...

* Согласованные предложения

  Начать стоит с предложений, уже принятых в следующую версию Стандарта.

** Атрибуты

   Известные мне компиляторы C каждый реализуют свое надмножество языкового стандарта.
   Помимо нестандартных языковых конструкций программисты могут указать в объявлениях
   специальные уточняющие поведение компиляторов /атрибуты/.

   Атрибуты в опубликованных версиях стандарта не упоминаются, но так или иначе
   [[https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html][реализованы]] [[https://clang.llvm.org/docs/AttributeReference.html][основными]] компиляторами.

   В новую версию стандарта принимается [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf][синтаксис]] для указани атрибутов. Пример из
   предложения:

   #+begin_src c
   [[attr1]] struct [[attr2]] S { } [[attr3]] s1 [[attr4]], s2 [[attr5]];
   #+end_src

   Здесь =attr1= относится к =s1= и =s2=, =attr2= относится к определению =struct S=, =attr3= - к типу
   =struct s1=, =attr4= - к идентификатору =s1=, =attr5= - к идентификатору =s2=.

   Заодно с синтаксисом были согласованы и некоторые атрибуты:

   1. Атрибут =deprecated= позволяет пометить объявление как устаревшее, при использовании
      таких объявлений компиляторам предлагается предупреждать программиста.

   2. Атрибутом =fallthrough= можно явно пометить места в ветвлениях =switch=, где поток
      исполнениях /должен/ обработать и следующую ветвь тоже.

   3. Явно указать необходимость обработки возвращаемого функцией значения можно с помощью
      атрибута =nodiscard=.

   4. Если переменная или функция осознанно не используется, то ее можно пометить
      атрибутом =maybe_unused= (а не почти уже идиоматичным =(void) unused_var=).

   5. Функцию, которая не вернется в место вызова, можно пометить атрибутом =noreturn=.

   Вроде мелочи, а приятно.

** Функции strdup и strndup

   Реализованные в POSIX, всех приличных стандартных библиотеках и компиляторах к нам,
   наконец, [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2353.htm][приходят]] функции =strdup= и =strndup=:

   #+begin_src c
     #include <string.h>

     char *strdup (const char *s);
     char *strndup (const char *s, size_t size);
   #+end_src

   Под Linux, естественно, я не мог заметить их отсутствия, но приятно, что Комитет иногда
   все же принимает неизбежное.

** Традиционный способ (K&R) указания параметров функций

   Устаревший еще в 1989 году способ объявления параметров функции, он же "объявление в
   стиле K&R", он же "когда типы после скобочек указываются", он же "я не понимаю старый
   код на C", будет, наконец, [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2432.pdf][сожжен на костре]].

   Другими словами, больше нельзя будет сделать так:

   #+begin_src c
     long maxl (a, b)
         long a, b;
     {
         return a > b ? a: b;
     }
   #+end_src

   И еще можно будет и так, и так:

   #+begin_src c
     /* вы же никогда не забывали void? */
     int no_args(void);
     /* ничего страшного, теперь это будет работать */
     int no_args();
   #+end_src

   Во втором случае ни одна панда не пострадает.

** Представление знаковых целых чисел

   Бесконечная история, наконец, пришла к завершению. Комитет [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2412.pdf][смирился]] с тем, что
   единорогов и сказочных архитектур не существует, а все пользователи C на практике имеют
   дело с [[https://ru.wikipedia.org/wiki/Дополнительный_код][дополнительным кодом]] (англ. /two's complement/) для представления знаковых целых
   чисел.

   В текущем виде это несколько упростит в деталях стандарт, но в перспективе может (!)
   убрать самое любимое программистами неопределенное поведение языка: переполнение
   знакового целого числа.

* Одобренные предложения

  Некоторые предложения были восприняты положительно, но были возвращены авторам на
  доработку. Ниже - те из них, что лично мне показались интересными.

** Безымянные параметры в определении функций

   За неделю я стабильно пишу одну-две пробные программки на C. И, признаться. мне уже
   давно надоело указывать имена неиспользованных аргументов =main=.

   [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2510.pdf][Одно]] из положительно воспринятых Комитетом предложений позволит не писать лишний раз
   имена параметров в определениях функций:

   #+begin_src c
     int main(int, char *[])
     {
         /* И никакой перхоти! */
         return 0;
     }
   #+end_src

** Введение новых ключевых слов

   После долгого переходного периода Комитет, наконец, решил больше не [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2457.pdf][придуриваться]] и
   [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2458.pdf][примет]] в язык, эм, "новые" ключевые слова: =true=, =false=, =alignas=, =alignof=, =bool=,
   =static_assert= и другие. Лишние заголовки вроде =<stdbool.h>=, кажется, можно будет
   почистить.

** Включение двоичных файлов в исходный файл

   Включение двоичных данных из файлов в исполняемый файл - невероятно полезная всем
   игроделам [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2499.pdf][возможность]] :

   #+begin_src c
     const int music[] = {
        #embed int "music.wav"
     };
   #+end_src

   Надеюсь, члены Комитета понимают, что Хабр знает, где они собираются в следующий раз и
   примут это предложение без вопросов.

** Прощай, NULL! Или nullptr на марше

   Кажется, на смену проблемному макросу NULL [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2394.pdf][приходит]], наконец, ключевое слово nullptr,
   которое будет эквивалентно выражению =((void*)0)=, но /не может быть преобразовано в
   неуказатели/. Любое использование NULL автор предложения предлагает сопровождать
   предупреждением компилятора.

** Реформа обработки ошибок в стандартной библиотеки

   Обработка ошибок функций стандартной библиотека - давняя проблема в C. Сочетание
   неудачных решений в ранних версиях стандарта, консервативности комитета и вопросов
   обратной совместимости не позволяли найти устраивающее всех решение.

   И вот, наконец, появился герой, готовый что-то [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2429.pdf][предложить]] одновременно разработчикам
   компиляторов, консервативному Комитету и, нам, простым смертным:

   #+begin_src c
     [[ oob_return_errno ]] int myabs (int x) {
         if(x == INT_MIN ) {
             oob_return_errno ( ERANGE , INT_MIN ) ;
         }
         return (x < 0) ? -x : x;
     }
   #+end_src

   Обратите внимание на атрибут =oob_return_errno=. Он означает, из этой функции-шаблона
   будут сгенерированы следующие функции:

   1. Возвращающая структуру с флагом ошибки и результатом работы функции (=struct {T
      return_value; int exception_code}=).

   2. Возвращающая результат работы функции и игнорирующая возможные ошибки в аргументах,
      приводя к неопределенному поведению.

   3. Завершающая выполнение в случае ошибки в аргументах.

   4. Меняющая =errno=, то есть имеющая привычное поведение.

   Компилятору предлагается выбирать между этими вариантами в зависимости от использования
   функции программистом:

   #+begin_src c
     bool flag;
     int result = oob_capture(&flag , myabs , input) ;
     if (flag) {
         abort ();
   #+end_src

   Здесь корректность выполнения функции сигнализируется флагом =flag=, причем =errno= не
   затрагивается. Аналогично выглядят, например, вызовы функций для захвата кода ошибки в
   переменную.

   Конкретный синтаксис, похоже, еще будет меняться, но хорошо, что Комитет хотя бы /думает/
   в эту сторону.

* Слухи

  Авторы Effective C совместно с другими участниками комитета [[https://news.ycombinator.com/item?id=22865357][отвечали]] на вопросы
  читателей англоязычного сообщества Hacker News. Вопросов и ответов там много, многое
  пересекается с отмеченными выше вещами.

  Но есть пара важных с точки зрения программиста предложений, которые в официальные
  предложения не оформлены, но участники комитета намекают, что какая-то работа в этом
  направлении все же проводится.

** Оператор typeof

   Ключевое слово =typeof= уже давно [[https://gcc.gnu.org/onlinedocs/gcc/Typeof.html#Typeof][реализовано]] в компиляторах и позволяет не повторяться
   при написании кода. Канонический пример:

   #+begin_src c
     #define max(a,b)                                \
         ({ typeof (a) _a = (a);                     \
         typeof (b) _b = (b);                        \
         _a > _b ? _a : _b; })
   #+end_src

   Мартин Себор (Martin Sebor), ведущий разработчик из Red Hat и участник Комитета,
   утверждает, что подобное расширение к языку уже находится в работе, и почти наверняка
   будет одобрено.

** Оператор defer

   Некоторые языки программирования, в том числе и реализованные на базе Clang и GCC,
   позволяют привязывать высобождение ресурсов в лексическим областам видимости
   переменных. Или, проще говоря, вызывать какой-то код с выходом переменной за границы
   текущего блока.

   В чистом C нет и никогда не было такой возможности, но компиляторы уже давно реализуют
   атрибут =cleanup(<cleanup function>)=:

   #+begin_src c
     int main(void)
     {
         __attribute__((cleanup(free))) char *s = malloc(sizeof(*s));
         return 0;}
   #+end_src

   Роберт Сикорд, автор Effective C и член Комитета, признался, что работает на
   предложением в стиле ключевого слова =defer= из Go:

   #+begin_src c
     int do_something(void) {
         FILE *file1, *file2;
         object_t *obj;
         file1 = fopen("a_file", "w");
         if (file1 == NULL) {
           return -1;
         }
         defer(fclose, file1);

         file2 = fopen("another_file", "w");
         if (file2 == NULL) {
           return -1;
         }
         defer(fclose, file2);

         /* ... */

         return 0;
       }

   #+end_src

   Должен заметить, что это стало бы революцией в ультраконсервативном мире разработки на
   C.

* Выводы

  Изменения в C как мутации в генетике: происходят редко, частенько бывают
  нежизнеспособны, но в итоге двигают эволюцию вперед.

  Последние неудачные изменения в C случились случились десять лет назад. Последний
  качественный скачок в разработке на языке случился больше двадцати лет назад. И, судя по
  всему, в этой итерации работы над Стандартом члены Комитета решили все-таки подумать над
  поступательным движением вперед.

  В общем, пользуйтесь статическими анализаторами, почаще запускайте valgrind и старайтесь
  не писать слишком больших программ на C!
