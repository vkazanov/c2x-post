* Аннотация

  #+begin_quote
Гул затих. Я вышел на подмостки.
Прислонясь к дверному косяку,
Я ловлю в далеком отголоске,
Что случится на моем веку.
-- "Гамлет", Борис Пастернак

  #+end_quote

  Признаться, пишу на чистом C я не так уж и часто, и за творчеством комитета WG14 уже
  давно не слежу. Но тут случилось два неожиданных события: С [[https://www.tiobe.com/tiobe-index/][вернул]] себе звание
  популярнейшего языка программирования по версии TIOBE; и случился анонс первой за долгие
  годы действительно [[https://nostarch.com/Effective_C][интересной книги]] по языку.

  События эти заставили меня провести несколько вечеров в чтении документов языкового
  Комитета и ознакомлении с [[https://news.ycombinator.com/item?id=22865357][перепиской]] членов комитета (и автора книги в том числе) с
  участниками известного онлайн-сообщества.

  Конечно, пересказ слухов и ставки на разультаты голосования комитета WG14 - дело
  неблагодарные. Но я все же собрал список интереснейших, на мой взгляд, из вероятных
  нововведений в эту статью.

* Согласованные Комитетом предложения

  Самое интересное это, конечно, это сплетни и слухи, но начну я все с банальностей, уже
  прошедших голосование и даже частично внесенных в последний черновой вариант Стандарта.

** Функции strdup и strndup

   Я, вероятно, покажусь невежой, когда скажу, что не знал об отсутствии этих функции в
   стандартной библиотеке. Казалось бы, что может быть очевидней и проще /копирования
   строк/?! Но нет, C не такой, это вам не POSIX.

   Итак, с опозданием лет на двадцать, но к нам все же [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2353.htm][приходят]] функции =strdup= и =strndup=!

   #+begin_src c
     #include <string.h>

     char *strdup (const char *s);
     char *strndup (const char *s, size_t size);
   #+end_src

   Приятно осознавать, что Комитет иногда все же принимает неизбежное.

** Атрибуты

   У разработчиков больших компиляторов C есть любимая игра: придумывать собственные
   расширения к языку в форме атрибутов объявлений и определений. Сам язык, конечно же,
   специального синтаксиса для таких вещей не предоставляет, поэтому каждый изощрается как
   может.

   Чтобы хоть как-то привести этот балаган к порядку без создания десятков новых ключевых
   слов Комитет придумал еще один синтаксис-который-будет-править-всеми.

   Словом, в следующей версии стандарта принимается [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2335.pdf][синтаксис]] для указания атрибутов.
   Пример из предложения:

   #+begin_src c
   [[attr1]] struct [[attr2]] S { } [[attr3]] s1 [[attr4]], s2 [[attr5]];
   #+end_src

   Здесь =attr1= относится к =s1= и =s2=, =attr2= относится к определению =struct S=, =attr3= - к типу
   =struct s1=, =attr4= - к идентификатору =s1=, =attr5= - к идентификатору =s2=.

   За включение атрибутов в стандарт Комитет уже проголосовал, а до публикации обновленной
   версии стандарта еще далеко. Поэтому авторы предложений пользуются новой игрушкой.
   Некоторые из предложенных атрибутов:

   1. Атрибут =deprecated= позволяет пометить объявление как устаревшее, при использовании
      таких объявлений компиляторам предлагается предупреждать программиста.

   2. Атрибутом =fallthrough= можно явно пометить места в ветвлениях =switch=, где поток
      исполнениях /должен/ обработать и следующую ветвь тоже.

   3. Явно указать необходимость обработки возвращаемого функцией значения можно с помощью
      атрибута =nodiscard=.

   4. Если переменная или функция осознанно не используется, то ее можно пометить
      атрибутом =maybe_unused= (а не почти уже идиоматичным =(void) unused_var=).

   5. Функцию, которая не вернется в место вызова, можно пометить атрибутом =noreturn=.


** Традиционный способ (K&R) указания параметров функций

   Устаревший еще в 1989 году способ объявления параметров функции, он же "объявление в
   стиле K&R", он же "когда типы после скобочек указываются", он же "я не понимаю старый
   код на C", будет, наконец, [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2432.pdf][сожжен на костре]], а я, наконец, расслаблюсь и перестану
   следить за своими =void=-ами.

   Другими словами, больше нельзя будет сделать так:

   #+begin_src c
     long maxl (a, b)
         long a, b;
     {
         return a > b ? a: b;
     }
   #+end_src

   Эпоха Просвещения приходит в код на C, потому что объявления функций будут делать
   именно то, что приличные люди от них ожидают:

   #+begin_src c
     /* объявление функции без аргументов */
     int no_args();

     /* тоже объявление функции без аргументов */
     int no_args(void);
   #+end_src

   Во втором случае ни одна панда не пострадает.

** Представление знаковых целых чисел

   Бесконечная история, наконец, пришла к завершению. Комитет [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2412.pdf][смирился]] с тем, что
   единорогов и сказочных архитектур не существует, а программисты на C имеют дело с
   [[https://ru.wikipedia.org/wiki/Дополнительный_код][дополнительным кодом]] (англ. /two's complement/) для представления знаковых целых чисел.

   В текущем виде это несколько упростит в деталях стандарт, но в перспективе может (!)
   убрать самое любимое программистами неопределенное поведение языка: переполнение
   знакового целого числа.

* Одобренные предложения

  Если перечисленные выше изменения уже, можно сказать, в нашей реальности, то следующая
  группа предложений все еще находится в разработке. Тем не менее, Комитет предварительно
  их одобрил и при должном усердии авторов они точно будут приняты.

** Безымянные параметры в определении функций

   За неделю я стабильно пишу одну-две пробные программки на C. И, признаться. мне уже
   давно надоело указывать имена неиспользованных аргументов =main=.

   [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2510.pdf][Одно]] из положительно воспринятых Комитетом предложений позволит не писать лишний раз
   имена параметров в определениях функций:

   #+begin_src c
     int main(int, char *[])
     {
         /* И никакой перхоти! */
         return 0;
     }
   #+end_src

   Мелочь, а какая приятная!

** Введение новых ключевых слов

   После долгого, доо-о-о-о-олгого переходного периода Комитет, наконец, решил больше не
   [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2457.pdf][придуриваться]] и [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2458.pdf][примет]] в язык, эм, "новые" ключевые слова: =true=, =false=, =alignas=,
   =alignof=, =bool=, =static_assert= и другие. Заголовки вроде =<stdbool.h>= можно будет,
   наконец, почистить.

** Включение двоичных файлов в исходный файл

   Включение двоичных данных из файлов в исполняемый файл - невероятно полезная всем
   игроделам [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2499.pdf][возможность]] :

   #+begin_src c
     const int music[] = {
        #embed int "music.wav"
     };
   #+end_src

   Надеюсь, члены Комитета понимают, что Хабру известно место проведения следующего
   заседания, и эта директива препроцессора будет принята без вопросов.

** Прощай, NULL! Или nullptr на марше

   Кажется, на смену проблемному макросу NULL [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2394.pdf][приходит]], наконец, ключевое слово nullptr,
   которое будет эквивалентно выражению =((void*)0)=, но /не может быть преобразовано в
   неуказатели/. Любое использование NULL автор предложения предлагает сопровождать
   предупреждением компилятора:

   #+begin_src c
     /* Вы же никогда не пишете просто NULL? Я вот до сих пор затылок чещу. */
     int execl(path, arg1, arg2, (char  *) NULL);

     /* Но счастье близко */
     int execl(path, arg1, arg2, nullptr);
   #+end_src

   Если пример вам ни о чем не говорит, то поищите =man 3 exec= под Linux, там будет
   пояснение.

** Реформа обработки ошибок в стандартной библиотеки

   Обработка ошибок функций стандартной библиотека - давняя проблема в C. Сочетание
   неудачных решений в ранних версиях стандарта, консервативности комитета и вопросов
   обратной совместимости не позволяли найти устраивающее всех решение.

   И вот, наконец, появился герой, готовый [[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2429.pdf][предложить]] решение одновременно разработчикам
   компиляторов, сверхконсервативному Комитету и, нам, простым смертным:

   #+begin_src c
     [[ oob_return_errno ]] int myabs (int x) {
         if(x == INT_MIN ) {
             oob_return_errno ( ERANGE , INT_MIN ) ;
         }
         return (x < 0) ? -x : x;
     }
   #+end_src

   Обратите внимание на атрибут =oob_return_errno=. Он означает, из этой функции-шаблона
   будут сгенерированы следующие функции:

   1. Возвращающая структуру с флагом ошибки и результатом работы функции (=struct {T
      return_value; int exception_code}=).

   2. Возвращающая результат работы функции и игнорирующая возможные ошибки в аргументах,
      приводя к неопределенному поведению.

   3. Завершающая выполнение в случае ошибки в аргументах.

   4. Меняющая =errno=, то есть имеющая привычное поведение.

   Компилятору предлагается выбирать между этими вариантами в зависимости от использования
   функции программистом:

   #+begin_src c
     bool flag;
     int result = oob_capture(&flag , myabs , input) ;
     if (flag) {
         abort ();
   #+end_src

   Здесь корректность выполнения функции сигнализируется флагом =flag=, причем =errno= не
   затрагивается. Аналогично выглядят, например, вызовы функций для захвата кода ошибки в
   переменную.

   Конкретный синтаксис, похоже, еще будет меняться, но хорошо, что Комитет хотя бы /думает/
   в эту сторону.

* Слухи

  Авторы Effective C совместно с другими участниками комитета [[https://news.ycombinator.com/item?id=22865357][отвечали]] на вопросы
  читателей англоязычного сообщества Hacker News. Вопросов и ответов там много, многое
  пересекается с отмеченными выше вещами.

  Но есть пара важных с точки зрения программиста предложений, которые в официальные
  предложения не оформлены, но участники комитета намекают, что какая-то работа в этом
  направлении все же проводится.

** Оператор typeof

   Ключевое слово =typeof= уже давно [[https://gcc.gnu.org/onlinedocs/gcc/Typeof.html#Typeof][реализовано]] в компиляторах и позволяет не повторяться
   при написании кода. Канонический пример:

   #+begin_src c
     #define max(a,b)                                \
         ({ typeof (a) _a = (a);                     \
         typeof (b) _b = (b);                        \
         _a > _b ? _a : _b; })
   #+end_src

   Мартин Себор (Martin Sebor), ведущий разработчик из Red Hat и участник Комитета,
   утверждает, что подобное расширение к языку уже находится в работе, и почти наверняка
   будет одобрено.

   Держу пальцы.

** Оператор defer

   Некоторые языки программирования, в том числе и реализованные на базе Clang и GCC,
   позволяют привязывать высобождение ресурсов в лексическим областам видимости
   переменных. Или, проще говоря, вызывать какой-то код с выходом программы из области
   видимости переменной.

   В чистом C нет и никогда не было такой возможности, но компиляторы уже давно реализуют
   атрибут =cleanup(<cleanup function>)=:

   #+begin_src c
     int main(void)
     {
         __attribute__((cleanup(free))) char *s = malloc(sizeof(*s));
         return 0;}
   #+end_src

   Роберт Сикорд, автор Effective C и член Комитета, признался, что работает на
   предложением в стиле ключевого слова =defer= из Go:

   #+begin_src c
     int do_something(void) {
         FILE *file1, *file2;
         object_t *obj;
         file1 = fopen("a_file", "w");
         if (file1 == NULL) {
           return -1;
         }
         defer(fclose, file1);

         file2 = fopen("another_file", "w");
         if (file2 == NULL) {
           return -1;
         }
         defer(fclose, file2);

         /* ... */

         return 0;
       }

   #+end_src

   Близится революция!

* Выводы

  Изменения в C это как мутации в генетике: происходят редко, частенько бывают
  нежизнеспособны, но в итоге двигают эволюцию вперед.

  Последние неудачные изменения в C случились случились десять лет назад. Последний
  качественный скачок в разработке на языке случился больше двадцати лет назад. И, судя по
  всему, в этой итерации работы над Стандартом члены Комитета решили все-таки подумать над
  поступательным движением вперед.

  В общем, пользуйтесь статическими анализаторами, почаще запускайте valgrind и старайтесь
  не писать слишком больших программ на C!
